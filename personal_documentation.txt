File: src\config\settings.py

What it does:
What It Implements (Short Summary)

A centralized configuration manager that:

Reads .env file automatically → No need to manually call load_dotenv()
Validates settings → If GEMINI_API_KEY is missing, it fails immediately with a clear error (not at runtime)
Type converts → CHUNK_SIZE = "500" (string in .env) becomes chunk_size = 500 (int in Python)
Provides defaults → Commented settings in .env use fallback values
Single source of truth → All config in one place, accessed via get_settings()

Before:

# Scattered across files
api_key = os.getenv("GEMINI_API_KEY")
chunk_size = int(os.getenv("CHUNK_SIZE", 500))

After:

# Clean, centralized
settings = get_settings()
settings.gemini_api_key
settings.chunk_size

Purpose:

Manage all app configuration in one place so you can:

Keep secrets (API keys) out of code
Change settings without modifying code
Catch config errors at startup, not runtime
Access settings consistently across all modules
One-liner: It's a type-safe, validated bridge between your .env file and Python code.

Note: The values like  "all-MiniLM-L6-v2" or numbers like 500, 50, etc are default values and changes with change in environment (.env) file.
 

---------------------------------------------

file: src\config\logging_config.py

what it does:

Creates a centralized logging system for your app.

In Simple Terms:

- Creates a logger named "FINRAG" that captures messages from your code
- Filters messages by level (only INFO and above are shown by default)
- Formats messages with timestamp, level, and your message
- Prints to console so you can see what your app is doing

The Flow:

Your code:  logger.info("Fetching data...")
                    ↓
Logger:     Checks if INFO ≥ minimum level (yes)
                    ↓
Formatter:  Adds timestamp + level
                    ↓
Handler:    Prints to console
                    ↓
Output:     2024-01-15 10:30:45 - INFO - Fetching data...

Why It's Useful:
Without Logging:
- print("error happened")
- No timestamp
- Hard to Filter
- messy in production

With Logging:
- logger.error("error happened")
- Automatic timestamp
- Filter by Level
- Professional Output

Log Levels (Low → High)
Level	  When to Use
DEBUG	  Detailed debugging info
INFO	  General progress messages
WARNING	  Something unexpected but not fatal
ERROR	  Something failed
CRITICAL  App cannot continue

How to Use
In any other file:

from src.config.logging_config import logger

# Log different levels
logger.debug("Detailed debug info")      # Won't show (below INFO)
logger.info("Processing started")        # ✅ Shows
logger.warning("Disk space low")         # ✅ Shows
logger.error("Connection failed")        # ✅ Shows
Output Example:

2024-01-15 10:30:45,123 - INFO - Processing started
2024-01-15 10:30:46,456 - WARNING - Disk space low
2024-01-15 10:30:47,789 - ERROR - Connection failed
Visual Flow:

Your code                    logging_config.py                Console
─────────                    ─────────────────                ───────
logger.info("Hi")  ──→  Logger("FINRAG")  ──→  StreamHandler  ──→  "2024... - INFO - Hi"
                              │
                              └─→ Formatter (timestamp + level + message)

------------------------------------------



